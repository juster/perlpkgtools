#!/usr/bin/perl
##
# Print a list of distributions that are bundled with perl. Dists are
# searched for inside the "dist" and "cpan" dirs inside the perl source dir.
#
# Args: The path to the perl source directory.
# Output: ["dist" or "cpan"] [dist name] [dist version]


use warnings;
use strict;

sub evalver
{
    my ($path, $mod) = @_;
    $mod ||= "";

    open my $fh, '<', $path or die "open $path: $!";

    while (<$fh>) {
        next unless /\s*(?:\$${mod}::|\$)VERSION\s*=\s*(.+)/;
        my $ver = eval $1;
        return $ver unless $@;
        warn qq{$path:$. bad version string "$ver"\n};
    }

    close $fh;
    return undef;
}

sub maindistfile
{
    my ($dist, $dir) = @_;


    my $libpath = join q{/}, 'lib', split /-/, "${dist}.pm";
    my ($dumbpath) = ($dist =~ /([^-]+)$/);
    $dumbpath .= ".pm";
    my @paths = ($libpath, $dumbpath);

    if ($dist =~ tr/-/-/ == 0) {
        # Some modules (with simple names) are generated by Makefile.PL.
        # (i.e. XSLoader, lib) Search through their to-be-generated text.
        push @paths, "${dist}_pm.PL";
    }

    for my $path (map { "$dir/$_" } @paths) {
        return $path if -f $path;
    }

    return undef;
}

sub module_ver
{
    my ($dist, $dir) = @_;

    my $path = maindistfile($dist, $dir);
    unless ($path) {
        return undef;
    }

    my $mod = $dist;
    $mod =~ s/-/::/g;

    my $ver = evalver($path, $mod);
    unless ($ver) {
        warn "failed to find version in module file for $dist\n";
        return undef;
    }

    return $ver;
}

sub changelog_ver
{
    my ($dist, $dir) = @_;

    my $path;
    for my $tmp (glob "$dir/{Changes,ChangeLog}") {
        if (-f $tmp) { $path = $tmp; last; }
    }
    return undef unless $path;

    open my $fh, '<', $path or die "open: $!";
    while (<$fh>) {
        return $1 if /\A\s*(?:$dist[ \t]*)?([0-9._]+)/;
        return $1 if /\A\s*version\s+([0-9._]+)/i;
    }
    close $fh;

    return undef;
}

# for some reason podlators has a VERSION file with perl code in it
sub verfile_ver
{
    my ($dist, $dir) = @_;

    my $path = "$dir/VERSION";
    return undef unless -f $path; # no warning, only podlaters has it

    return evalver($path);
}

# scans a directory full of nicely separated dist. directories.
sub scan_distroot
{
    my ($distroot) = @_;
    opendir my $cpand, "$distroot" or die "failed to open $distroot";
    my @dists = grep { !/^\./ && -d "$distroot/$_" } readdir $cpand;
    closedir $cpand;

    my @found;
    for my $dist (@dists) {
        my $distdir = "$distroot/$dist";
        my $ver = (module_ver($dist, $distdir)
                   || changelog_ver($dist, $distdir)
                   || verfile_ver($dist, $distdir));

        if ($ver) { push @found, $dist, $ver; }
        else { warn "failed to find version for $dist\n"; }
    }
    return \@found;
}

my $srcdir = shift @ARGV or die "Usage: $0 [perl source dir]\n";

die "$srcdir is not a directory" unless -d $srcdir;

for my $subdir (qw/cpan dist/) {
    my $found_ref = scan_distroot("$srcdir/$subdir");
    while (@$found_ref > 0) {
        my ($dist, $ver) = splice @$found_ref, 0, 2;
        print "$subdir $dist $ver\n";
    }
}
